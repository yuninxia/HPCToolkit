// SPDX-FileCopyrightText: Contributors to the HPCToolkit Project
//
// SPDX-License-Identifier: BSD-3-Clause

// -*-Mode: C++;-*-

#ifndef HPCTOOLKIT_PROFILE_LEXICAL_H
#define HPCTOOLKIT_PROFILE_LEXICAL_H

#include "util/uniqable.hpp"
#include "util/ragged_vector.hpp"
#include "util/ref_wrappers.hpp"
#include "util/stable_hash.hpp"

#include "stdshim/filesystem.hpp"
#include <string>
#include <string_view>

namespace hpctoolkit {

namespace util {
class stable_hash_state;
}

class Module;

/// Application source File. Main data is just the full path to the source file,
/// but also includes userdata for more complex handling.
class File {
public:
  using ud_t = util::ragged_vector<const File&>;

  // Files must be created by the Pipeline
  File() = delete;
  ~File() = default;

  // Minimal motion for STL containers
  File(File&&);
  File(const File&) = delete;
  File& operator=(File&&) = delete;
  File& operator=(const File&) = delete;

  /// Get the full path to the source file
  // MT: Safe (const)
  const stdshim::filesystem::path& path() const { return u_path; }

  mutable ud_t userdata;

private:
  util::uniqable_key<stdshim::filesystem::path> u_path;

  File(ud_t::struct_t& rs, stdshim::filesystem::path p);

  friend class util::uniqued<File>;
  util::uniqable_key<stdshim::filesystem::path>& uniqable_key() {
    return u_path;
  }
};

util::stable_hash_state& operator<<(util::stable_hash_state&, const File&) noexcept;

/// High-level application Function(-like construct), within a particular
/// Module. These do not have userdata and are not allocated by the Pipeline.
///
/// It is expected that every Function object is a different logical/lexical
/// function in the source code.
class Function {
public:
  /// Functions can be constructed with some or all of their pieces.
  /// The arguments follow the available getter methods.
  explicit Function(const Module& mod)
    : Function(mod, std::nullopt) {};
  Function(const Module& mod, std::optional<uint64_t> offset)
    : Function(mod, offset, std::string()) {};
  Function(const Module&, std::optional<uint64_t>, std::string);
  Function(const Module& mod, std::string name, const File& file, uint64_t line)
    : Function(mod, std::nullopt, std::move(name), file, line) {};
  Function(const Module&, std::optional<uint64_t>, std::string, const File&, uint64_t);

  ~Function() = default;

  // Movable and copiable
  Function(Function&&) = default;
  Function(const Function&) = default;
  Function& operator=(Function&&) = default;
  Function& operator=(const Function&) = default;

  // Comparable
  bool operator==(const Function& o) const noexcept {
    return m_module == o.m_module && m_offset == o.m_offset && m_name == o.m_name
           && ((!m_file && !o.m_file)
               || (m_file && o.m_file && &*m_file == &*o.m_file && m_line == o.m_line));
  }
  bool operator!=(const Function& o) const noexcept { return !operator==(o); }

  /// Get the Module this Function is fully contained within.
  // MT: Safe (const)
  const Module& module() const noexcept { return *m_module; }

  /// Get the offset of this Function within the Module. For binaries, this is
  /// usually the offset of the entry instruction.
  /// If the offset is not known, returns std::nullopt.
  // MT: Safe (const)
  std::optional<uint64_t> offset() const noexcept { return m_offset; }

  /// Set the offset of this Function within its Module. The offset must not
  /// have been set in this Function prior to this call.
  // MT: Externally Synchronized
  void offset(uint64_t) noexcept;

  /// Get the name for this Function. If multiple names are available, this is
  /// the most human-readable one.
  /// If empty, this is an anonymous Function.
  // MT: Safe (const)
  const std::string& name() const noexcept { return m_name; }

  /// Set the name for this Function. The name must have been empty prior to
  /// this call, and `name` cannot be empty.
  // MT: Externally Synchronized
  void name(std::string) noexcept;

  /// Get the source file and line where this Function was defined.
  /// If unknown, returns std::nullopt.
  // MT: Safe (const)
  std::optional<std::pair<const File&, uint64_t>> sourceLocation() const noexcept {
    if(!m_file) return std::nullopt;
    return std::pair<const File&, uint64_t>(*m_file, m_line);
  }

  /// Set the source File and line where this Function was defined. The location
  /// must not have been set in this Function prior to this call.
  // MT: Externally Synchronized
  void sourceLocation(const File&, uint64_t) noexcept;

  /// Merge this Function with another, filling in data that is unknown in this
  /// Function and known in `other`. If the data between the two differ, a
  /// consistent one is chosen for the final result (i.e. += is commutative).
  // MT: Externally Synchronized
  Function& operator+=(const Function& other) noexcept;
  Function& operator+=(Function&& other) noexcept;

private:
  void mergeSmall(const Function&) noexcept;

  const Module* m_module;
  std::optional<uint64_t> m_offset;
  std::string m_name;
  util::optional_ref<const File> m_file;
  uint64_t m_line;
};

util::stable_hash_state& operator<<(util::stable_hash_state&, const Function&) noexcept;

}  // namespace hpctoolkit

template<>
struct std::hash<hpctoolkit::Function> {
  hpctoolkit::util::stable_hash<hpctoolkit::Function> stable;
  std::size_t operator()(const hpctoolkit::Function& f) const noexcept {
    return stable(f);
  }
};

#endif  // HPCTOOLKIT_PROFILE_LEXICAL_H
